<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Events</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 616px;
      height: 960px;
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      color: #222;
      overflow: hidden;
      text-align: left;
    }

    #events {
      padding: 10px 15px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
    }

    .event {
      background: white;
      padding: 10px;
      margin-bottom: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    .event h3 {
      margin: 0;
      font-size: 1.1em;
      color: #800000;
    }

    .event time,
    .event .location {
      display: block;
      margin-top: 4px;
      font-size: 0.95em;
    }
  </style>
</head>
<body>
  <div id="events">Loading...</div>

  <script>
    async function fetchICS() {
      const baseICSUrl = 'https://www.romeoville.org/common/modules/iCalendar/iCalendar.aspx?catID=61&feed=calendar';
      const proxiedUrl = 'https://corsproxy.io/?' + encodeURIComponent(baseICSUrl);

      try {
        const response = await fetch(proxiedUrl);
        const data = await response.text();

        const events = [];
        const entries = data.split('BEGIN:VEVENT').slice(1);

        entries.forEach(entry => {
          const summary = entry.match(/SUMMARY:(.*)/)?.[1]?.trim();
          const location = entry.match(/LOCATION:(.*)/)?.[1]?.trim();
          const dtstartRaw = entry.match(/DTSTART.*:(.*)/)?.[1]?.trim();
          const dtendRaw = entry.match(/DTEND.*:(.*)/)?.[1]?.trim();

          if (!summary || !dtstartRaw || !parseDateTime(dtstartRaw)) return;

          const dtstart = formatDateTime(dtstartRaw);
          const dtend = formatDateTime(dtendRaw);

          const startDateObj = parseDateTime(dtstartRaw);
          if (startDateObj && startDateObj < new Date()) return;

          events.push({ summary, location, dtstart, dtend, rawStart: dtstartRaw });
        });

        // Sort events by raw start date
        events.sort((a, b) => parseDateTimeRaw(a.rawStart) - parseDateTimeRaw(b.rawStart));

        displayEvents(events);
      } catch (err) {
        document.getElementById('events').innerHTML = `<p>Error loading calendar: ${err.message}</p>`;
      }
    }

    function parseDateTime(raw) {
      if (!raw) return null;

      if (/^\d{8}$/.test(raw)) {
        const dt = new Date(`${raw.slice(0, 4)}-${raw.slice(4, 6)}-${raw.slice(6, 8)}`);
        return isNaN(dt) ? null : dt;
      }

      if (/^\d{8}T\d{6}Z?$/.test(raw)) {
        const dtStr = raw.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z?/, '$1-$2-$3T$4:$5:$6');
        const dt = new Date(dtStr);
        return isNaN(dt) ? null : dt;
      }

      const dt = new Date(raw);
      return isNaN(dt) ? null : dt;
    }

    function parseDateTimeRaw(raw) {
      const dt = parseDateTime(raw);
      return dt ? dt.getTime() : 0;
    }

    function formatDateTime(raw) {
      const dt = parseDateTime(raw);
      if (!dt) return 'Invalid date';
      return dt.toLocaleString(undefined, {
        dateStyle: 'medium',
        timeStyle: 'short'
      });
    }

    function displayEvents(events) {
      const container = document.getElementById('events');
      container.innerHTML = '';

      const upcoming = events.slice(0, 10);

      if (upcoming.length === 0) {
        container.innerHTML = '<p>No upcoming events found.</p>';
        return;
      }

      upcoming.forEach(evt => {
        const div = document.createElement('div');
        div.className = 'event';
        div.innerHTML = `
          <h3>${evt.summary}</h3>
          <time>${evt.dtstart} â€“ ${evt.dtend}</time>
          <div class="location">${evt.location || ''}</div>
        `;
        container.appendChild(div);
      });
    }

    function scheduleMidnightReload() {
      const now = new Date();
      const midnight = new Date();
      midnight.setHours(24, 0, 0, 0);
      const msUntilMidnight = midnight.getTime() - now.getTime();
      setTimeout(() => location.reload(), msUntilMidnight);
    }

    fetchICS();
    setInterval(fetchICS, 60 * 60 * 1000);
    scheduleMidnightReload();
  </script>
</body>
</html>
